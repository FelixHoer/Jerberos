package kerberos.protocol.tgs;

import java.util.Date;
import java.util.Map;

import kerberos.protocol.Processable;
import kerberos.protocol.SecurityUtilities;
import kerberos.protocol.dto.Authenticator;
import kerberos.protocol.dto.Encrypted;
import kerberos.protocol.dto.TGSRequest;
import kerberos.protocol.dto.TGSResponse;
import kerberos.protocol.dto.Ticket;
import kerberos.serialize.SerializeUtilities;

public class TGSProtocol implements Processable<TGSRequest, TGSResponse>{

    private final TGSConfiguration config;

    public TGSProtocol(TGSConfiguration config) {
        this.config = config;
    }

    /**
     * Processes an incoming request and answers with an appropriate response.
     * 
     * The request contains two parts.
     * 
     * The first part is the Ticket generated by the Authentication-Server,
     * which is encrypted with the TGS-Key. This ticket contains the Session-Key 
     * used by the client for the second part.
     * 
     * The second part is an encrypted authenticator which contains the client's
     * name and the time the request was sent.
     * 
     * If decryption and validation of the authenticator succeeded the response
     * will be generated.
     * 
     * To send a response the following two Parts have to be created.
     * The first is a encrypted Session-Key for Client and Service.
     * The second is a Ticket for the Service, which contains the Session-Key 
     * from part one and some additional information. This Ticket is encrypted 
     * with the long time shared secret of the desired service.
     * 
     * @param request the request sent by the client
     * @return the response generated by the server
     * @throws Exception if decryption or validation failed
     */
    @Override
    public TGSResponse process(TGSRequest request) throws Exception {
        Map<String, byte[]> serverKeys = config.getServerKeys();
        byte[] tgsKey = config.getTgsKey();

        Ticket oldTicket = request.getTicket().decrypt(tgsKey, Ticket.class);

        byte[] oldSessionKey = oldTicket.getSessionKey();
        byte[] serverKey = serverKeys.get(oldTicket.getServiceName());

        Authenticator auth = request.getAuthenticator().decrypt(oldSessionKey, Authenticator.class);

        if(!auth.getClientName().equals(oldTicket.getClientName()))
            throw new Exception("client names do not match");

        Date now = new Date();
        Date authTime = auth.getTime();
        Date min = new Date(now.getTime() - 8 * 60 * 60 * 1000); // 8h ago
        Date max = new Date(now.getTime() + 60 * 1000); // 1min from now
        if(authTime.before(min) || authTime.after(max))
            throw new Exception("out of time frame: " + authTime);

        byte[] newSessionKey = SecurityUtilities.generateKey();
        System.out.println("Generated Session Key: " + SerializeUtilities.toBase64(newSessionKey));

        Ticket ticket = new Ticket();
        ticket.setClientName(oldTicket.getClientName());
        ticket.setServiceName(oldTicket.getServiceName());
        ticket.setSessionKey(newSessionKey);
        ticket.setStartTime(now);
        long endTime = now.getTime() + 8 * 60 * 60 * 1000; // 8h from now
        ticket.setEndTime(new Date(endTime));

        TGSResponse res = new TGSResponse();
        res.setSessionKey(new Encrypted(newSessionKey, oldSessionKey));
        res.setTicket(new Encrypted(ticket, serverKey));
        return res;
    }

}
