package kerberos.protocol.client;

import java.util.Date;

import kerberos.protocol.dto.Authenticator;
import kerberos.protocol.dto.Encrypted;
import kerberos.protocol.dto.ServiceRequest;
import kerberos.protocol.dto.ServiceResponse;
import kerberos.protocol.dto.TGSResponse;
import kerberos.serialize.SerializeUtilities;
import kerberos.stack.Stack;

public class ServiceClientProtocol{

    private final Stack stack;
    private final ClientConfiguration config;
    private final TGSClientProtocol tgsClient;

    private ServiceResponse serviceResponse;
    private byte[] serviceSessionKey;
    private Date sentTime;

    /**
     * Sends a request to the Ticket Granting Server and blocks until it 
     * receives an an response. 
     * @param config the client configuration containing addresses and keys
     * @param asClient contains the response of the Authentication-Server
     * @throws Exception if the protocol could not be executed correctly
     */
    public ServiceClientProtocol(ClientConfiguration config, 
            TGSClientProtocol tgsClient) throws Exception {
        this.config = config;
        this.tgsClient = tgsClient;
        stack = new Stack(config.getServiceAddress());

        this.request();
        this.receive();

        // leave stack open for further communication
    }

    /**
     * Sends a request that consists of two parts.
     * 
     * The first part is the Ticket generated by the Ticket-Grainting-Server,
     * which is encrypted with the Service-Key. This ticket contains the 
     * Session-Key used by the client for the second part.
     * 
     * The second part is an encrypted authenticator which contains the client's
     * name and the time the request was sent.
     * 
     * @throws Exception if the request could not be generated of sent
     */
    private void request() throws Exception{
        TGSResponse tgsResponse = tgsClient.getResponse();
        byte[] tgsSessionKey = tgsClient.getSessionKey();

        serviceSessionKey = tgsResponse.getSessionKey().decrypt(tgsSessionKey);
        System.out.println("Received Session Key: " 
                + SerializeUtilities.toBase64(serviceSessionKey));

        sentTime = new Date();

        System.out.println("-- Requesting Service --");

        Authenticator serverAuth = new Authenticator();
        serverAuth.setClientName(config.getClientName());
        serverAuth.setTime(sentTime);

        ServiceRequest serviceRequest = new ServiceRequest();
        serviceRequest.setAuthenticator(new Encrypted(serverAuth, 
                serviceSessionKey));
        serviceRequest.setTicket(tgsResponse.getTicket());

        stack.write(serviceRequest);
    }

    /**
     * Reads the response of the service and checks if it contains the sent
     * time incremented by one.
     * If so, the currently used Session-Key will be used to encrypt further 
     * communication.
     * @throws Exception if the response could not be red
     */
    private void receive() throws Exception{
        System.out.println("-- Received Service --");

        Object object = stack.read();
        serviceResponse = (ServiceResponse) object;

        System.out.println("-- Checking Authentication --");

        Date receivedTime = serviceResponse.getTimePlusOne().decrypt(
                serviceSessionKey, Date.class);

        System.out.println("time:   " + sentTime.getTime());
        System.out.println("time+1: " + receivedTime.getTime());

        if(sentTime.getTime()+1 == receivedTime.getTime()){
            System.out.println("Authentication successful!");
        }else{
            System.out.println("Authentication failed!");
            throw new Exception("Authentication failed!");
        }
    }

    public ServiceResponse getResponse() {
        return serviceResponse;
    }

    public byte[] getSessionKey() {
        return serviceSessionKey;
    }

    public Date getSentTime() {
        return sentTime;
    }

    public Stack getStack() {
        return stack;
    }

}
